{"ast":null,"code":"const _excluded = [\"theme\", \"type\"],\n  _excluded2 = [\"delay\", \"staleId\"];\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\nimport e, { isValidElement as t, useRef as n, useLayoutEffect as o, useEffect as s, cloneElement as a, useReducer as r, useState as i, forwardRef as c } from \"react\";\nimport l from \"clsx\";\nfunction u(e) {\n  return \"number\" == typeof e && !isNaN(e);\n}\nfunction d(e) {\n  return \"boolean\" == typeof e;\n}\nfunction p(e) {\n  return \"string\" == typeof e;\n}\nfunction m(e) {\n  return \"function\" == typeof e;\n}\nfunction f(e) {\n  return p(e) || m(e) ? e : null;\n}\nfunction g(e) {\n  return 0 === e || e;\n}\nfunction y(e) {\n  return t(e) || p(e) || m(e) || u(e);\n}\nconst h = {\n    TOP_LEFT: \"top-left\",\n    TOP_RIGHT: \"top-right\",\n    TOP_CENTER: \"top-center\",\n    BOTTOM_LEFT: \"bottom-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    BOTTOM_CENTER: \"bottom-center\"\n  },\n  T = {\n    INFO: \"info\",\n    SUCCESS: \"success\",\n    WARNING: \"warning\",\n    ERROR: \"error\",\n    DEFAULT: \"default\"\n  };\nfunction v(e, t, n) {\n  void 0 === n && (n = 300);\n  const o = e.scrollHeight,\n    s = e.style;\n  requestAnimationFrame(() => {\n    s.minHeight = \"initial\", s.height = o + \"px\", s.transition = \"all \" + n + \"ms\", requestAnimationFrame(() => {\n      s.height = \"0\", s.padding = \"0\", s.margin = \"0\", setTimeout(t, n);\n    });\n  });\n}\nfunction E(t) {\n  let a = t.enter,\n    r = t.exit,\n    _t$appendPosition = t.appendPosition,\n    i = _t$appendPosition === void 0 ? !1 : _t$appendPosition,\n    _t$collapse = t.collapse,\n    c = _t$collapse === void 0 ? !0 : _t$collapse,\n    _t$collapseDuration = t.collapseDuration,\n    l = _t$collapseDuration === void 0 ? 300 : _t$collapseDuration;\n  return function (t) {\n    let u = t.children,\n      d = t.position,\n      p = t.preventExitTransition,\n      m = t.done,\n      f = t.nodeRef,\n      g = t.isIn;\n    const y = i ? a + \"--\" + d : a,\n      h = i ? r + \"--\" + d : r,\n      T = n(),\n      E = n(0);\n    function b(e) {\n      if (e.target !== f.current) return;\n      const t = f.current;\n      t.dispatchEvent(new Event(\"d\")), t.removeEventListener(\"animationend\", b), t.removeEventListener(\"animationcancel\", b), 0 === E.current && \"animationcancel\" !== e.type && (t.className = T.current);\n    }\n    function C() {\n      const e = f.current;\n      e.removeEventListener(\"animationend\", C), c ? v(e, m, l) : m();\n    }\n    return o(() => {\n      !function () {\n        const e = f.current;\n        T.current = e.className, e.className += \" \" + y, e.addEventListener(\"animationend\", b), e.addEventListener(\"animationcancel\", b);\n      }();\n    }, []), s(() => {\n      g || (p ? C() : function () {\n        E.current = 1;\n        const e = f.current;\n        e.className += \" \" + h, e.addEventListener(\"animationend\", C);\n      }());\n    }, [g]), e.createElement(e.Fragment, null, u);\n  };\n}\nfunction b(e, t) {\n  return {\n    content: e.content,\n    containerId: e.props.containerId,\n    id: e.props.toastId,\n    theme: e.props.theme,\n    type: e.props.type,\n    data: e.props.data || {},\n    isLoading: e.props.isLoading,\n    icon: e.props.icon,\n    status: t\n  };\n}\nconst C = {\n    list: new Map(),\n    emitQueue: new Map(),\n    on(e, t) {\n      return this.list.has(e) || this.list.set(e, []), this.list.get(e).push(t), this;\n    },\n    off(e, t) {\n      if (t) {\n        const n = this.list.get(e).filter(e => e !== t);\n        return this.list.set(e, n), this;\n      }\n      return this.list.delete(e), this;\n    },\n    cancelEmit(e) {\n      const t = this.emitQueue.get(e);\n      return t && (t.forEach(clearTimeout), this.emitQueue.delete(e)), this;\n    },\n    emit(e) {\n      this.list.has(e) && this.list.get(e).forEach(t => {\n        const n = setTimeout(() => {\n          t(...[].slice.call(arguments, 1));\n        }, 0);\n        this.emitQueue.has(e) || this.emitQueue.set(e, []), this.emitQueue.get(e).push(n);\n      });\n    }\n  },\n  _ = t => {\n    let n = t.theme,\n      o = t.type,\n      s = _objectWithoutProperties(t, _excluded);\n    return e.createElement(\"svg\", _objectSpread({\n      viewBox: \"0 0 24 24\",\n      width: \"100%\",\n      height: \"100%\",\n      fill: \"colored\" === n ? \"currentColor\" : \"var(--toastify-icon-color-\" + o + \")\"\n    }, s));\n  },\n  I = {\n    info: function (t) {\n      return e.createElement(_, _objectSpread({}, t), e.createElement(\"path\", {\n        d: \"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"\n      }));\n    },\n    warning: function (t) {\n      return e.createElement(_, _objectSpread({}, t), e.createElement(\"path\", {\n        d: \"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"\n      }));\n    },\n    success: function (t) {\n      return e.createElement(_, _objectSpread({}, t), e.createElement(\"path\", {\n        d: \"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"\n      }));\n    },\n    error: function (t) {\n      return e.createElement(_, _objectSpread({}, t), e.createElement(\"path\", {\n        d: \"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"\n      }));\n    },\n    spinner: function () {\n      return e.createElement(\"div\", {\n        className: \"Toastify__spinner\"\n      });\n    }\n  };\nfunction O(e) {\n  const _r = r(e => e + 1, 0),\n    _r2 = _slicedToArray(_r, 2),\n    o = _r2[1],\n    _i = i([]),\n    _i2 = _slicedToArray(_i, 2),\n    c = _i2[0],\n    l = _i2[1],\n    h = n(null),\n    T = n(new Map()).current,\n    v = e => -1 !== c.indexOf(e),\n    E = n({\n      toastKey: 1,\n      displayedToast: 0,\n      count: 0,\n      queue: [],\n      props: e,\n      containerId: null,\n      isToastActive: v,\n      getToast: e => T.get(e)\n    }).current;\n  function _(e) {\n    let t = e.containerId;\n    const n = E.props.limit;\n    !n || t && E.containerId !== t || (E.count -= E.queue.length, E.queue = []);\n  }\n  function O(e) {\n    l(t => g(e) ? t.filter(t => t !== e) : []);\n  }\n  function L() {\n    const _E$queue$shift = E.queue.shift(),\n      e = _E$queue$shift.toastContent,\n      t = _E$queue$shift.toastProps,\n      n = _E$queue$shift.staleId;\n    P(e, t, n);\n  }\n  function N(e, n) {\n    let s = n.delay,\n      r = n.staleId,\n      i = _objectWithoutProperties(n, _excluded2);\n    if (!y(e) || function (e) {\n      return !h.current || E.props.enableMultiContainer && e.containerId !== E.props.containerId || T.has(e.toastId) && null == e.updateId;\n    }(i)) return;\n    const c = i.toastId,\n      l = i.updateId,\n      v = i.data,\n      _ = E.props,\n      N = () => O(c),\n      x = null == l;\n    x && E.count++;\n    const R = {\n      toastId: c,\n      updateId: l,\n      data: v,\n      containerId: i.containerId,\n      isLoading: i.isLoading,\n      theme: i.theme || _.theme,\n      icon: null != i.icon ? i.icon : _.icon,\n      isIn: !1,\n      key: i.key || E.toastKey++,\n      type: i.type,\n      closeToast: N,\n      closeButton: i.closeButton,\n      rtl: _.rtl,\n      position: i.position || _.position,\n      transition: i.transition || _.transition,\n      className: f(i.className || _.toastClassName),\n      bodyClassName: f(i.bodyClassName || _.bodyClassName),\n      style: i.style || _.toastStyle,\n      bodyStyle: i.bodyStyle || _.bodyStyle,\n      onClick: i.onClick || _.onClick,\n      pauseOnHover: d(i.pauseOnHover) ? i.pauseOnHover : _.pauseOnHover,\n      pauseOnFocusLoss: d(i.pauseOnFocusLoss) ? i.pauseOnFocusLoss : _.pauseOnFocusLoss,\n      draggable: d(i.draggable) ? i.draggable : _.draggable,\n      draggablePercent: i.draggablePercent || _.draggablePercent,\n      draggableDirection: i.draggableDirection || _.draggableDirection,\n      closeOnClick: d(i.closeOnClick) ? i.closeOnClick : _.closeOnClick,\n      progressClassName: f(i.progressClassName || _.progressClassName),\n      progressStyle: i.progressStyle || _.progressStyle,\n      autoClose: !i.isLoading && (k = i.autoClose, B = _.autoClose, !1 === k || u(k) && k > 0 ? k : B),\n      hideProgressBar: d(i.hideProgressBar) ? i.hideProgressBar : _.hideProgressBar,\n      progress: i.progress,\n      role: i.role || _.role,\n      deleteToast() {\n        const e = b(T.get(c), \"removed\");\n        T.delete(c), C.emit(4, e);\n        const t = E.queue.length;\n        if (E.count = g(c) ? E.count - 1 : E.count - E.displayedToast, E.count < 0 && (E.count = 0), t > 0) {\n          const e = g(c) ? 1 : E.props.limit;\n          if (1 === t || 1 === e) E.displayedToast++, L();else {\n            const n = e > t ? t : e;\n            E.displayedToast = n;\n            for (let e = 0; e < n; e++) L();\n          }\n        } else o();\n      }\n    };\n    var k, B;\n    R.iconOut = function (e) {\n      let n = e.theme,\n        o = e.type,\n        s = e.isLoading,\n        r = e.icon,\n        i = null;\n      const c = {\n        theme: n,\n        type: o\n      };\n      return !1 === r || (m(r) ? i = r(c) : t(r) ? i = a(r, c) : p(r) || u(r) ? i = r : s ? i = I.spinner() : (e => e in I)(o) && (i = I[o](c))), i;\n    }(R), m(i.onOpen) && (R.onOpen = i.onOpen), m(i.onClose) && (R.onClose = i.onClose), R.closeButton = _.closeButton, !1 === i.closeButton || y(i.closeButton) ? R.closeButton = i.closeButton : !0 === i.closeButton && (R.closeButton = !y(_.closeButton) || _.closeButton);\n    let M = e;\n    t(e) && !p(e.type) ? M = a(e, {\n      closeToast: N,\n      toastProps: R,\n      data: v\n    }) : m(e) && (M = e({\n      closeToast: N,\n      toastProps: R,\n      data: v\n    })), _.limit && _.limit > 0 && E.count > _.limit && x ? E.queue.push({\n      toastContent: M,\n      toastProps: R,\n      staleId: r\n    }) : u(s) ? setTimeout(() => {\n      P(M, R, r);\n    }, s) : P(M, R, r);\n  }\n  function P(e, t, n) {\n    const o = t.toastId;\n    n && T.delete(n);\n    const s = {\n      content: e,\n      props: t\n    };\n    T.set(o, s), l(e => [...e, o].filter(e => e !== n)), C.emit(4, b(s, null == s.props.updateId ? \"added\" : \"updated\"));\n  }\n  return s(() => (E.containerId = e.containerId, C.cancelEmit(3).on(0, N).on(1, e => h.current && O(e)).on(5, _).emit(2, E), () => C.emit(3, E)), []), s(() => {\n    E.props = e, E.isToastActive = v, E.displayedToast = c.length;\n  }), {\n    getToastToRender: function (t) {\n      const n = new Map(),\n        o = Array.from(T.values());\n      return e.newestOnTop && o.reverse(), o.forEach(e => {\n        const t = e.props.position;\n        n.has(t) || n.set(t, []), n.get(t).push(e);\n      }), Array.from(n, e => t(e[0], e[1]));\n    },\n    containerRef: h,\n    isToastActive: v\n  };\n}\nfunction L(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;\n}\nfunction N(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;\n}\nfunction P(e) {\n  const _i3 = i(!1),\n    _i4 = _slicedToArray(_i3, 2),\n    o = _i4[0],\n    a = _i4[1],\n    _i5 = i(!1),\n    _i6 = _slicedToArray(_i5, 2),\n    r = _i6[0],\n    c = _i6[1],\n    l = n(null),\n    u = n({\n      start: 0,\n      x: 0,\n      y: 0,\n      delta: 0,\n      removalDistance: 0,\n      canCloseOnClick: !0,\n      canDrag: !1,\n      boundingRect: null,\n      didMove: !1\n    }).current,\n    d = n(e),\n    p = e.autoClose,\n    f = e.pauseOnHover,\n    g = e.closeToast,\n    y = e.onClick,\n    h = e.closeOnClick;\n  function T(t) {\n    if (e.draggable) {\n      u.didMove = !1, document.addEventListener(\"mousemove\", C), document.addEventListener(\"mouseup\", _), document.addEventListener(\"touchmove\", C), document.addEventListener(\"touchend\", _);\n      const n = l.current;\n      u.canCloseOnClick = !0, u.canDrag = !0, u.boundingRect = n.getBoundingClientRect(), n.style.transition = \"\", u.x = L(t.nativeEvent), u.y = N(t.nativeEvent), \"x\" === e.draggableDirection ? (u.start = u.x, u.removalDistance = n.offsetWidth * (e.draggablePercent / 100)) : (u.start = u.y, u.removalDistance = n.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent / 100));\n    }\n  }\n  function v() {\n    if (u.boundingRect) {\n      const _u$boundingRect = u.boundingRect,\n        t = _u$boundingRect.top,\n        n = _u$boundingRect.bottom,\n        o = _u$boundingRect.left,\n        s = _u$boundingRect.right;\n      e.pauseOnHover && u.x >= o && u.x <= s && u.y >= t && u.y <= n ? b() : E();\n    }\n  }\n  function E() {\n    a(!0);\n  }\n  function b() {\n    a(!1);\n  }\n  function C(t) {\n    const n = l.current;\n    u.canDrag && n && (u.didMove = !0, o && b(), u.x = L(t), u.y = N(t), u.delta = \"x\" === e.draggableDirection ? u.x - u.start : u.y - u.start, u.start !== u.x && (u.canCloseOnClick = !1), n.style.transform = \"translate\" + e.draggableDirection + \"(\" + u.delta + \"px)\", n.style.opacity = \"\" + (1 - Math.abs(u.delta / u.removalDistance)));\n  }\n  function _() {\n    document.removeEventListener(\"mousemove\", C), document.removeEventListener(\"mouseup\", _), document.removeEventListener(\"touchmove\", C), document.removeEventListener(\"touchend\", _);\n    const t = l.current;\n    if (u.canDrag && u.didMove && t) {\n      if (u.canDrag = !1, Math.abs(u.delta) > u.removalDistance) return c(!0), void e.closeToast();\n      t.style.transition = \"transform 0.2s, opacity 0.2s\", t.style.transform = \"translate\" + e.draggableDirection + \"(0)\", t.style.opacity = \"1\";\n    }\n  }\n  s(() => {\n    d.current = e;\n  }), s(() => (l.current && l.current.addEventListener(\"d\", E, {\n    once: !0\n  }), m(e.onOpen) && e.onOpen(t(e.children) && e.children.props), () => {\n    const e = d.current;\n    m(e.onClose) && e.onClose(t(e.children) && e.children.props);\n  }), []), s(() => (e.pauseOnFocusLoss && (document.hasFocus() || b(), window.addEventListener(\"focus\", E), window.addEventListener(\"blur\", b)), () => {\n    e.pauseOnFocusLoss && (window.removeEventListener(\"focus\", E), window.removeEventListener(\"blur\", b));\n  }), [e.pauseOnFocusLoss]);\n  const I = {\n    onMouseDown: T,\n    onTouchStart: T,\n    onMouseUp: v,\n    onTouchEnd: v\n  };\n  return p && f && (I.onMouseEnter = b, I.onMouseLeave = E), h && (I.onClick = e => {\n    y && y(e), u.canCloseOnClick && g();\n  }), {\n    playToast: E,\n    pauseToast: b,\n    isRunning: o,\n    preventExitTransition: r,\n    toastRef: l,\n    eventHandlers: I\n  };\n}\nfunction x(t) {\n  let n = t.closeToast,\n    o = t.theme,\n    _t$ariaLabel = t.ariaLabel,\n    s = _t$ariaLabel === void 0 ? \"close\" : _t$ariaLabel;\n  return e.createElement(\"button\", {\n    className: \"Toastify__close-button Toastify__close-button--\" + o,\n    type: \"button\",\n    onClick: e => {\n      e.stopPropagation(), n(e);\n    },\n    \"aria-label\": s\n  }, e.createElement(\"svg\", {\n    \"aria-hidden\": \"true\",\n    viewBox: \"0 0 14 16\"\n  }, e.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n  })));\n}\nfunction R(t) {\n  let n = t.delay,\n    o = t.isRunning,\n    s = t.closeToast,\n    a = t.type,\n    r = t.hide,\n    i = t.className,\n    c = t.style,\n    u = t.controlledProgress,\n    d = t.progress,\n    p = t.rtl,\n    f = t.isIn,\n    g = t.theme;\n  const y = _objectSpread(_objectSpread({}, c), {}, {\n    animationDuration: n + \"ms\",\n    animationPlayState: o ? \"running\" : \"paused\",\n    opacity: r ? 0 : 1\n  });\n  u && (y.transform = \"scaleX(\" + d + \")\");\n  const h = l(\"Toastify__progress-bar\", u ? \"Toastify__progress-bar--controlled\" : \"Toastify__progress-bar--animated\", \"Toastify__progress-bar-theme--\" + g, \"Toastify__progress-bar--\" + a, {\n      \"Toastify__progress-bar--rtl\": p\n    }),\n    T = m(i) ? i({\n      rtl: p,\n      type: a,\n      defaultClassName: h\n    }) : l(h, i);\n  return e.createElement(\"div\", {\n    role: \"progressbar\",\n    \"aria-hidden\": r ? \"true\" : \"false\",\n    \"aria-label\": \"notification timer\",\n    className: T,\n    style: y,\n    [u && d >= 1 ? \"onTransitionEnd\" : \"onAnimationEnd\"]: u && d < 1 ? null : () => {\n      f && s();\n    }\n  });\n}\nR.defaultProps = {\n  type: T.DEFAULT,\n  hide: !1\n};\nconst k = t => {\n    const _P = P(t),\n      n = _P.isRunning,\n      o = _P.preventExitTransition,\n      s = _P.toastRef,\n      a = _P.eventHandlers,\n      r = t.closeButton,\n      i = t.children,\n      c = t.autoClose,\n      u = t.onClick,\n      d = t.type,\n      p = t.hideProgressBar,\n      f = t.closeToast,\n      g = t.transition,\n      y = t.position,\n      h = t.className,\n      T = t.style,\n      v = t.bodyClassName,\n      E = t.bodyStyle,\n      b = t.progressClassName,\n      C = t.progressStyle,\n      _ = t.updateId,\n      I = t.role,\n      O = t.progress,\n      L = t.rtl,\n      N = t.toastId,\n      k = t.deleteToast,\n      B = t.isIn,\n      M = t.isLoading,\n      D = t.iconOut,\n      w = t.theme,\n      A = l(\"Toastify__toast\", \"Toastify__toast-theme--\" + w, \"Toastify__toast--\" + d, {\n        \"Toastify__toast--rtl\": L\n      }),\n      F = m(h) ? h({\n        rtl: L,\n        position: y,\n        type: d,\n        defaultClassName: A\n      }) : l(A, h),\n      S = !!O,\n      z = {\n        closeToast: f,\n        type: d,\n        theme: w\n      };\n    let H = null;\n    return !1 === r || (H = m(r) ? r(z) : e.isValidElement(r) ? e.cloneElement(r, z) : x(z)), e.createElement(g, {\n      isIn: B,\n      done: k,\n      position: y,\n      preventExitTransition: o,\n      nodeRef: s\n    }, e.createElement(\"div\", _objectSpread(_objectSpread({\n      id: N,\n      onClick: u,\n      className: F\n    }, a), {}, {\n      style: T,\n      ref: s\n    }), e.createElement(\"div\", _objectSpread(_objectSpread({}, B && {\n      role: I\n    }), {}, {\n      className: m(v) ? v({\n        type: d\n      }) : l(\"Toastify__toast-body\", v),\n      style: E\n    }), null != D && e.createElement(\"div\", {\n      className: l(\"Toastify__toast-icon\", {\n        \"Toastify--animate-icon Toastify__zoom-enter\": !M\n      })\n    }, D), e.createElement(\"div\", null, i)), H, (c || S) && e.createElement(R, _objectSpread(_objectSpread({}, _ && !S ? {\n      key: \"pb-\" + _\n    } : {}), {}, {\n      rtl: L,\n      theme: w,\n      delay: c,\n      isRunning: n,\n      isIn: B,\n      closeToast: f,\n      hide: p,\n      type: d,\n      style: C,\n      className: b,\n      controlledProgress: S,\n      progress: O\n    }))));\n  },\n  B = E({\n    enter: \"Toastify--animate Toastify__bounce-enter\",\n    exit: \"Toastify--animate Toastify__bounce-exit\",\n    appendPosition: !0\n  }),\n  M = E({\n    enter: \"Toastify--animate Toastify__slide-enter\",\n    exit: \"Toastify--animate Toastify__slide-exit\",\n    appendPosition: !0\n  }),\n  D = E({\n    enter: \"Toastify--animate Toastify__zoom-enter\",\n    exit: \"Toastify--animate Toastify__zoom-exit\"\n  }),\n  w = E({\n    enter: \"Toastify--animate Toastify__flip-enter\",\n    exit: \"Toastify--animate Toastify__flip-exit\"\n  }),\n  A = c((t, n) => {\n    const _O = O(t),\n      o = _O.getToastToRender,\n      a = _O.containerRef,\n      r = _O.isToastActive,\n      i = t.className,\n      c = t.style,\n      u = t.rtl,\n      d = t.containerId;\n    function p(e) {\n      const t = l(\"Toastify__toast-container\", \"Toastify__toast-container--\" + e, {\n        \"Toastify__toast-container--rtl\": u\n      });\n      return m(i) ? i({\n        position: e,\n        rtl: u,\n        defaultClassName: t\n      }) : l(t, f(i));\n    }\n    return s(() => {\n      n && (n.current = a.current);\n    }, []), e.createElement(\"div\", {\n      ref: a,\n      className: \"Toastify\",\n      id: d\n    }, o((t, n) => {\n      const o = n.length ? _objectSpread({}, c) : _objectSpread(_objectSpread({}, c), {}, {\n        pointerEvents: \"none\"\n      });\n      return e.createElement(\"div\", {\n        className: p(t),\n        style: o,\n        key: \"container-\" + t\n      }, n.map((t, o) => {\n        let s = t.content,\n          a = t.props;\n        return e.createElement(k, _objectSpread(_objectSpread({}, a), {}, {\n          isIn: r(a.toastId),\n          style: _objectSpread(_objectSpread({}, a.style), {}, {\n            \"--nth\": o + 1,\n            \"--len\": n.length\n          }),\n          key: \"toast-\" + a.key\n        }), s);\n      }));\n    }));\n  });\nA.displayName = \"ToastContainer\", A.defaultProps = {\n  position: h.TOP_RIGHT,\n  transition: B,\n  rtl: !1,\n  autoClose: 5e3,\n  hideProgressBar: !1,\n  closeButton: x,\n  pauseOnHover: !0,\n  pauseOnFocusLoss: !0,\n  closeOnClick: !0,\n  newestOnTop: !1,\n  draggable: !0,\n  draggablePercent: 80,\n  draggableDirection: \"x\",\n  role: \"alert\",\n  theme: \"light\"\n};\nlet F,\n  S = new Map(),\n  z = [];\nfunction H() {\n  return Math.random().toString(36).substring(2, 9);\n}\nfunction q(e) {\n  return e && (p(e.toastId) || u(e.toastId)) ? e.toastId : H();\n}\nfunction U(e, t) {\n  return S.size > 0 ? C.emit(0, e, t) : z.push({\n    content: e,\n    options: t\n  }), t.toastId;\n}\nfunction Q(e, t) {\n  return _objectSpread(_objectSpread({}, t), {}, {\n    type: t && t.type || e,\n    toastId: q(t)\n  });\n}\nfunction G(e) {\n  return (t, n) => U(t, Q(e, n));\n}\nfunction W(e, t) {\n  return U(e, Q(T.DEFAULT, t));\n}\nW.loading = (e, t) => U(e, Q(T.DEFAULT, _objectSpread({\n  isLoading: !0,\n  autoClose: !1,\n  closeOnClick: !1,\n  closeButton: !1,\n  draggable: !1\n}, t))), W.promise = function (e, t, n) {\n  let o,\n    s = t.pending,\n    a = t.error,\n    r = t.success;\n  s && (o = p(s) ? W.loading(s, n) : W.loading(s.render, _objectSpread(_objectSpread({}, n), s)));\n  const i = {\n      isLoading: null,\n      autoClose: null,\n      closeOnClick: null,\n      closeButton: null,\n      draggable: null,\n      delay: 100\n    },\n    c = (e, t, s) => {\n      if (null == t) return void W.dismiss(o);\n      const a = _objectSpread(_objectSpread(_objectSpread({\n          type: e\n        }, i), n), {}, {\n          data: s\n        }),\n        r = p(t) ? {\n          render: t\n        } : t;\n      return o ? W.update(o, _objectSpread(_objectSpread({}, a), r)) : W(r.render, _objectSpread(_objectSpread({}, a), r)), s;\n    },\n    l = m(e) ? e() : e;\n  return l.then(e => c(\"success\", r, e)).catch(e => c(\"error\", a, e)), l;\n}, W.success = G(T.SUCCESS), W.info = G(T.INFO), W.error = G(T.ERROR), W.warning = G(T.WARNING), W.warn = W.warning, W.dark = (e, t) => U(e, Q(T.DEFAULT, _objectSpread({\n  theme: \"dark\"\n}, t))), W.dismiss = e => C.emit(1, e), W.clearWaitingQueue = function (e) {\n  return void 0 === e && (e = {}), C.emit(5, e);\n}, W.isActive = e => {\n  let t = !1;\n  return S.forEach(n => {\n    n.isToastActive && n.isToastActive(e) && (t = !0);\n  }), t;\n}, W.update = function (e, t) {\n  void 0 === t && (t = {}), setTimeout(() => {\n    const n = function (e, t) {\n      let n = t.containerId;\n      const o = S.get(n || F);\n      return o ? o.getToast(e) : null;\n    }(e, t);\n    if (n) {\n      const o = n.props,\n        s = n.content,\n        a = _objectSpread(_objectSpread(_objectSpread({}, o), t), {}, {\n          toastId: t.toastId || e,\n          updateId: H()\n        });\n      a.toastId !== e && (a.staleId = e);\n      const r = a.render || s;\n      delete a.render, U(r, a);\n    }\n  }, 0);\n}, W.done = e => {\n  W.update(e, {\n    progress: 1\n  });\n}, W.onChange = e => (C.on(4, e), () => {\n  C.off(4, e);\n}), W.POSITION = h, W.TYPE = T, C.on(2, e => {\n  F = e.containerId || e, S.set(F, e), z.forEach(e => {\n    C.emit(0, e.content, e.options);\n  }), z = [];\n}).on(3, e => {\n  S.delete(e.containerId || e), 0 === S.size && C.off(0).off(1).off(5);\n});\nexport { B as Bounce, w as Flip, I as Icons, M as Slide, A as ToastContainer, D as Zoom, v as collapseToast, E as cssTransition, W as toast, P as useToast, O as useToastContainer };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}